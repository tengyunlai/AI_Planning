## ABOUT LEC 2

## Domain independent heuristics

â€¢ Deriving heuristics for individual problems is time consuming 

â€¢ Domain independent heuristics tend to work well in planning

â€¢ Need specific representations

å¦‚æœè¦å»ºç«‹ä¸€ä¸ªå¯å‘å¼çš„planningï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™æœ‰ä¸¤ä¸ªé—®é¢˜ã€‚ä¸€ä¸ªæ˜¯Domain dependentçš„æ¯”è¾ƒæœ‰å±€é™æ€§ï¼Œè€Œå¦‚æœä½¿ç”¨å¹¿ä¹‰çš„heuristicsä¼šæ¶‰åŠåˆ°ä½¿ç”¨ç‰¹æ®Šçš„è¡¨è¾¾æ–¹å¼ã€‚

è¯¾ç¨‹çš„ä»»åŠ¡å°±æ˜¯ï¼š

â€‹	We will look at specifying planning problems using 

â€‹	â€¢ STRIPS

â€‹	â€¢ Satisfiability

â€‹	â€¢ Planning graph

## Logic notation é€»è¾‘æœ¯è¯­

**Term**: an object in the world. Can be a variable, constant or function

â€‹	eg: a, shaky, 

**Atomic sentence** or **Atom**: a predicate symbol, optionally followed by a parenthesized list of terms

â€‹	eg: Brother(a,b)

**Literal**: atom or its negation

â€‹	eg: Brother(a,b)   Â¬Brother(a,b)

 **Ground literal**: A literal with no variable

â€‹	eg: Brother (Jack, John)

**Sentence** or **Formula**: Formed from atoms together with quantifiers (âˆ€, âˆƒ), logical connectives (âˆ§,âˆ¨, Â¬), equality symbol (=)

â€‹	Sentence can take values *ğ‘‡ğ‘Ÿğ‘¢ğ‘’* or *ğ¹ğ‘ğ‘™ğ‘ ğ‘’* â€¢ E.g.,

**Substitution**: replaces variables by terms â€¢ E.g., [x/y]

**Unifier**: takes 2 sentences and returns a substitution that makes the sentence look identical, if such a substitution exists

â€¢ E.g., *Unify*( Brother(x,y), Brother(x,z))
 We cannot say ğ‘ˆğ‘›ğ‘–ğ‘“ğ‘¦(ğµğ‘Ÿğ‘œğ‘¡hğ‘’ğ‘Ÿ(ğ½ğ‘œhğ‘›, ğ‘¥), ğ‘€ğ‘œğ‘¡hğ‘’ğ‘Ÿ(ğ‘¦, ğ½ğ‘ğ‘›ğ‘’))

**most general unifier (MGU)**:

## components To specify a problem

1. Initial state
2. Goal test
3. Set of actions
4. Transition model 
5. Path cost

**STRIPS** have:

- Initial state 
- Actions available
- Result of applying an action in a state
- Goal state

## STRIPS

State is represented by a **conjunction of positive literals** that are **grounded and function-free**

State is a **conjunction fluent**s. E.g., ğ´ğ‘¡ ğ‘‡ğ‘Ÿğ‘¢ğ‘ğ‘˜1, ğ‘‡ğ‘¢ğ‘ğ‘  âˆ§ ğ´ğ‘¡(ğ‘‡ğ‘Ÿğ‘¢ğ‘ğ‘˜2, ğ‘Šğ‘œğ‘œğ‘‘ğ‘™ğ‘ğ‘›ğ‘‘ğ‘ )

Literals are **grounded boolean variables**, which are ğ´ğ‘¡(ğ‘‡ğ‘Ÿğ‘¢ğ‘ğ‘˜1,ğ‘‡ğ‘¢ğ‘ğ‘ )

### NOT allowed in state description

â€¢ E.g., ğ´ğ‘¡(ğ‘¥, ğ‘¦) because it is not grounded
 â€¢ Â¬ğ‘ƒğ‘œğ‘œğ‘Ÿ because it is a negation
 â€¢ ğ´ğ‘¡(ğ¹ğ‘ğ‘¡hğ‘’ğ‘Ÿ(ğ¹ğ‘Ÿğ‘’ğ‘‘), ğ‘†ğ‘¦ğ‘‘ğ‘›ğ‘’ğ‘¦) because Strips doesnâ€™t allow functions

**Goal** is a **partially specified stat**e, represented as a conjunction of **positive ground literals**

**Action schema**: A set of actions, using lifted representationä½¿ç”¨å‡é™å¼è¡¨ç¤º

EG:
ğ´ğ‘ğ‘¡ğ‘–ğ‘œğ‘›(ğ¹ğ‘™ğ‘¦(ğ‘, ğ‘“ğ‘Ÿğ‘œğ‘š, ğ‘¡ğ‘œ),

ğ‘ƒğ‘Ÿğ‘’ğ‘ğ‘œğ‘›ğ‘‘: ğ´ğ‘¡ ğ‘, ğ‘“ğ‘Ÿğ‘œğ‘š âˆ§ ğ‘ƒğ‘™ğ‘ğ‘›ğ‘’ ğ‘ âˆ§ ğ´ğ‘–ğ‘Ÿğ‘ğ‘œğ‘Ÿğ‘¡ ğ‘“ğ‘Ÿğ‘œğ‘š âˆ§ ğ´ğ‘–ğ‘Ÿğ‘ğ‘œğ‘Ÿğ‘¡(ğ‘¡ğ‘œ) 

ğ¸ğ‘“ğ‘“ğ‘’ğ‘ğ‘¡:Â¬ğ´ğ‘¡ ğ‘,ğ‘“ğ‘Ÿğ‘œğ‘š âˆ§ğ´ğ‘¡(ğ‘,ğ‘¡ğ‘œ))

**Ground actions** : obtained by instantiating(å®ä¾‹åŒ–) the variables in the schema

E.g.,
 ğ´ğ‘ğ‘¡ğ‘–ğ‘œğ‘›(ğ¹ğ‘™ğ‘¦(ğ‘ƒ , ğ‘†ğ¹ğ‘‚, ğ‘†ğ¼ğ‘),

ğ‘ƒğ‘Ÿğ‘’ğ‘ğ‘œğ‘›ğ‘‘: ğ´ğ‘¡ ğ‘ƒ , ğ‘†ğ¹ğ‘‚ âˆ§ ğ‘ƒğ‘™ğ‘ğ‘›ğ‘’ ğ‘ƒ âˆ§ ğ´ğ‘–ğ‘Ÿğ‘ğ‘œğ‘Ÿğ‘¡ ğ‘†ğ¹ğ‘‚ âˆ§ ğ´ğ‘–ğ‘Ÿğ‘ğ‘œğ‘Ÿğ‘¡(ğ‘†ğ¼ğ‘)

ğ¸ğ‘“ğ‘“ğ‘’ğ‘ğ‘¡:Â¬ğ´ğ‘¡ğ‘ƒ,ğ‘†ğ¹ğ‘‚ âˆ§ğ´ğ‘¡(ğ‘ƒ,ğ‘†ğ¼ğ‘))

**Preconditions & effects**: conjunctions of literals.

â€‹	Precondition is a conjunction of function-free positive literals

**Effects** â€“ conjunction of **function-free (positive/negative) literals**

**fluents**: Result of executing ğ‘ in state ğ‘  is a state ğ‘ â€² which is a set of fluents formed as follows.

â€‹	FOR instance:

1.  Start from *s*

2. Remove fluents that appear as negative literals in the effect (delete list) ***DEL(a)***

3. Add fluents that appear as positive literals in the effect (add list) ***ADD(a)***

   **RESULT** (**s,a**) = (**s** - **DEL(a)**) **âˆª** **ADD(a)**

### SUMMARY

â€¢ State: conjunction of ground **positive function-free** literals

â€‹		**Closed world** assumption

â€¢ Goal: conjunction of ground **positive function-free** literals 

â€‹		Satisfied by **states that contain all literals**

â€¢ Action precondition: conjunction of **function-free** literals

â€¢ Action effects: conjunction of **function-free** literals 

â€‹		â€¢ Positive literals for add list
â€‹		â€¢ Negative literals for delete list

### Problems of STRIPS

â€¢ Efficient to solve (âˆµ of restrictions) 

â€¢ Hard to describe the problem

## Planning domain

### what is planning domain

**A set of action schemas** define planning domain, which is problem space.

Planning problem â€“ **action schema** + initial state + goal

## PDDL

###  Action Description Language (ADL)

1. â€¢ positive and negative literals in states, open world assumption
2. â€¢ **quantified variables** at goal, **conjunctions and disjunctions** at goal
3.  â€¢ conditional effects
4.  â€¢ equality predicate, typed variables å¹³ç­‰è°“è¯ï¼Œç±»å‹åŒ–å˜é‡

**PDDL â€“ ADL + extensions**

### difference between STRIPS and PDDL

â€¢ **Inequality predicate â€“ not in STRIPS but available in PDDL**

â€‹		â€¢ If no inequality, need to explicitly specify such predicates 

â€‹				â€¢ E.g.,ğ‘â‰ ğ‘¥

â€¢ To move a block, precondition â€“ nothing on top of it

- Â¬âˆƒğ‘¥ ğ‘‚ğ‘›(ğ‘¥, ğ‘) or âˆ€ğ‘¥ Â¬ğ‘‚ğ‘›(ğ‘¥, ğ‘) in first-order logic
- **Strips/PDDL doesnâ€™t allow quantifiers**(Eg. âˆƒ), so we use ğ¶ğ‘™ğ‘’ğ‘ğ‘Ÿ ğ‘ , which is true when nothing is on b

â€¢ Table not same as block â€“ think ğ¶ğ‘™ğ‘’ğ‘ğ‘Ÿ(ğ‘‡ğ‘ğ‘ğ‘™ğ‘’)?

â€‹		â€¢ Define ğ¶ğ‘™ğ‘’ğ‘ğ‘Ÿ(ğ‘‡ğ‘ğ‘ğ‘™ğ‘’) or generalize ğ¶ğ‘™ğ‘’ğ‘ğ‘Ÿ(ğ‘¥) behavior

â€‹		â€¢ Introduce ğ‘€ğ‘œğ‘£ğ‘’ğ‘‡ğ‘œğ‘‡ğ‘ğ‘ğ‘™ğ‘’(ğ‘, ğ‘¥) to allow different behavior
